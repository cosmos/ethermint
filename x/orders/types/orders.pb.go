// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ethermint/orders/v1beta1/orders.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// An object describing a derivative market in the Injective Futures Protocol.
type DerivativeMarket struct {
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Address of the oracle for the derivative contract
	Oracle string `protobuf:"bytes,2,opt,name=oracle,proto3" json:"oracle,omitempty"`
	// Address of the base currency for the derivative contract
	BaseCurrency string `protobuf:"bytes,3,opt,name=base_currency,json=baseCurrency,proto3" json:"base_currency,omitempty"`
	// Random number to faciltate uniqueness of the derivative market ID
	Nonce string `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *DerivativeMarket) Reset()         { *m = DerivativeMarket{} }
func (m *DerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*DerivativeMarket) ProtoMessage()    {}
func (*DerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{0}
}
func (m *DerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DerivativeMarket.Merge(m, src)
}
func (m *DerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *DerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_DerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_DerivativeMarket proto.InternalMessageInfo

func (m *DerivativeMarket) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *DerivativeMarket) GetOracle() string {
	if m != nil {
		return m.Oracle
	}
	return ""
}

func (m *DerivativeMarket) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *DerivativeMarket) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *DerivativeMarket) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *DerivativeMarket) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// An object describing trade pair of two assets.
type TradePair struct {
	// A name of the pair in format AAA/BBB, where AAA - maker's asset, BBB -
	// taker's asset.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,2,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,3,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	// Hash of both asset data, to identify the trading pair in store.
	Hash string `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *TradePair) Reset()         { *m = TradePair{} }
func (m *TradePair) String() string { return proto.CompactTextString(m) }
func (*TradePair) ProtoMessage()    {}
func (*TradePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{1}
}
func (m *TradePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradePair.Merge(m, src)
}
func (m *TradePair) XXX_Size() int {
	return m.Size()
}
func (m *TradePair) XXX_DiscardUnknown() {
	xxx_messageInfo_TradePair.DiscardUnknown(m)
}

var xxx_messageInfo_TradePair proto.InternalMessageInfo

func (m *TradePair) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TradePair) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *TradePair) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *TradePair) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *TradePair) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// A contract set.
type ContractSet struct {
	// Coordinator contract address.
	CoordinatorContract string `protobuf:"bytes,1,opt,name=coordinator_contract,json=coordinatorContract,proto3" json:"coordinator_contract,omitempty"`
	// Exchange DevUtils contract address.
	DevUtilsContract string `protobuf:"bytes,2,opt,name=dev_utils_contract,json=devUtilsContract,proto3" json:"dev_utils_contract,omitempty"`
	// Exchange v3 contract address.
	ExchangeContract string `protobuf:"bytes,3,opt,name=exchange_contract,json=exchangeContract,proto3" json:"exchange_contract,omitempty"`
	// Futures contract address.
	FuturesContract string `protobuf:"bytes,4,opt,name=futures_contract,json=futuresContract,proto3" json:"futures_contract,omitempty"`
}

func (m *ContractSet) Reset()         { *m = ContractSet{} }
func (m *ContractSet) String() string { return proto.CompactTextString(m) }
func (*ContractSet) ProtoMessage()    {}
func (*ContractSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{2}
}
func (m *ContractSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractSet.Merge(m, src)
}
func (m *ContractSet) XXX_Size() int {
	return m.Size()
}
func (m *ContractSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractSet.DiscardUnknown(m)
}

var xxx_messageInfo_ContractSet proto.InternalMessageInfo

func (m *ContractSet) GetCoordinatorContract() string {
	if m != nil {
		return m.CoordinatorContract
	}
	return ""
}

func (m *ContractSet) GetDevUtilsContract() string {
	if m != nil {
		return m.DevUtilsContract
	}
	return ""
}

func (m *ContractSet) GetExchangeContract() string {
	if m != nil {
		return m.ExchangeContract
	}
	return ""
}

func (m *ContractSet) GetFuturesContract() string {
	if m != nil {
		return m.FuturesContract
	}
	return ""
}

// A valid signed 0x order based on the schema.
type BaseOrder struct {
	// Specify chain ID.
	ChainId int64 `protobuf:"zigzag64,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Exchange v3 contract address.
	ExchangeAddress string `protobuf:"bytes,2,opt,name=exchange_address,json=exchangeAddress,proto3" json:"exchange_address,omitempty"`
	// Address that created the order.
	MakerAddress string `protobuf:"bytes,3,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress string `protobuf:"bytes,4,opt,name=taker_address,json=takerAddress,proto3" json:"taker_address,omitempty"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress string `protobuf:"bytes,5,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress string `protobuf:"bytes,6,opt,name=sender_address,json=senderAddress,proto3" json:"sender_address,omitempty"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount string `protobuf:"bytes,7,opt,name=maker_asset_amount,json=makerAssetAmount,proto3" json:"maker_asset_amount,omitempty"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount string `protobuf:"bytes,8,opt,name=taker_asset_amount,json=takerAssetAmount,proto3" json:"taker_asset_amount,omitempty"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee string `protobuf:"bytes,9,opt,name=maker_fee,json=makerFee,proto3" json:"maker_fee,omitempty"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee string `protobuf:"bytes,10,opt,name=taker_fee,json=takerFee,proto3" json:"taker_fee,omitempty"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds string `protobuf:"bytes,11,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt string `protobuf:"bytes,12,opt,name=salt,proto3" json:"salt,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `protobuf:"bytes,13,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `protobuf:"bytes,14,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData string `protobuf:"bytes,15,opt,name=maker_fee_asset_data,json=makerFeeAssetData,proto3" json:"maker_fee_asset_data,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData string `protobuf:"bytes,16,opt,name=taker_fee_asset_data,json=takerFeeAssetData,proto3" json:"taker_fee_asset_data,omitempty"`
	// Order signature.
	Signature string `protobuf:"bytes,17,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *BaseOrder) Reset()         { *m = BaseOrder{} }
func (m *BaseOrder) String() string { return proto.CompactTextString(m) }
func (*BaseOrder) ProtoMessage()    {}
func (*BaseOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{3}
}
func (m *BaseOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseOrder.Merge(m, src)
}
func (m *BaseOrder) XXX_Size() int {
	return m.Size()
}
func (m *BaseOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseOrder.DiscardUnknown(m)
}

var xxx_messageInfo_BaseOrder proto.InternalMessageInfo

func (m *BaseOrder) GetChainId() int64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *BaseOrder) GetExchangeAddress() string {
	if m != nil {
		return m.ExchangeAddress
	}
	return ""
}

func (m *BaseOrder) GetMakerAddress() string {
	if m != nil {
		return m.MakerAddress
	}
	return ""
}

func (m *BaseOrder) GetTakerAddress() string {
	if m != nil {
		return m.TakerAddress
	}
	return ""
}

func (m *BaseOrder) GetFeeRecipientAddress() string {
	if m != nil {
		return m.FeeRecipientAddress
	}
	return ""
}

func (m *BaseOrder) GetSenderAddress() string {
	if m != nil {
		return m.SenderAddress
	}
	return ""
}

func (m *BaseOrder) GetMakerAssetAmount() string {
	if m != nil {
		return m.MakerAssetAmount
	}
	return ""
}

func (m *BaseOrder) GetTakerAssetAmount() string {
	if m != nil {
		return m.TakerAssetAmount
	}
	return ""
}

func (m *BaseOrder) GetMakerFee() string {
	if m != nil {
		return m.MakerFee
	}
	return ""
}

func (m *BaseOrder) GetTakerFee() string {
	if m != nil {
		return m.TakerFee
	}
	return ""
}

func (m *BaseOrder) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *BaseOrder) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *BaseOrder) GetMakerAssetData() string {
	if m != nil {
		return m.MakerAssetData
	}
	return ""
}

func (m *BaseOrder) GetTakerAssetData() string {
	if m != nil {
		return m.TakerAssetData
	}
	return ""
}

func (m *BaseOrder) GetMakerFeeAssetData() string {
	if m != nil {
		return m.MakerFeeAssetData
	}
	return ""
}

func (m *BaseOrder) GetTakerFeeAssetData() string {
	if m != nil {
		return m.TakerFeeAssetData
	}
	return ""
}

func (m *BaseOrder) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type Order struct {
	Order         *BaseOrder `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	TradePairHash string     `protobuf:"bytes,2,opt,name=trade_pair_hash,json=tradePairHash,proto3" json:"trade_pair_hash,omitempty"`
	FilledAmount  string     `protobuf:"bytes,3,opt,name=filled_amount,json=filledAmount,proto3" json:"filled_amount,omitempty"`
	Status        int64      `protobuf:"zigzag64,4,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{4}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetOrder() *BaseOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *Order) GetTradePairHash() string {
	if m != nil {
		return m.TradePairHash
	}
	return ""
}

func (m *Order) GetFilledAmount() string {
	if m != nil {
		return m.FilledAmount
	}
	return ""
}

func (m *Order) GetStatus() int64 {
	if m != nil {
		return m.Status
	}
	return 0
}

type SignedTransaction struct {
	// Arbitrary number to facilitate uniqueness of the transactions's hash.
	Salt string `protobuf:"bytes,1,opt,name=salt,proto3" json:"salt,omitempty"`
	// Address of transaction signer
	SignerAddress string `protobuf:"bytes,2,opt,name=signer_address,json=signerAddress,proto3" json:"signer_address,omitempty"`
	// The calldata that is to be executed. This must call an Exchange contract
	// method.
	Data string `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	// Timestamp in seconds at which transaction expires.
	ExpirationTimeSeconds string `protobuf:"bytes,4,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// gasPrice that transaction is required to be executed with.
	GasPrice string `protobuf:"bytes,5,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	// Exchange Domain specific values.
	Domain *ExchangeDomain `protobuf:"bytes,6,opt,name=domain,proto3" json:"domain,omitempty"`
	// Signature of the 0x Transaction
	Signature string `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SignedTransaction) Reset()         { *m = SignedTransaction{} }
func (m *SignedTransaction) String() string { return proto.CompactTextString(m) }
func (*SignedTransaction) ProtoMessage()    {}
func (*SignedTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{5}
}
func (m *SignedTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTransaction.Merge(m, src)
}
func (m *SignedTransaction) XXX_Size() int {
	return m.Size()
}
func (m *SignedTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTransaction proto.InternalMessageInfo

func (m *SignedTransaction) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *SignedTransaction) GetSignerAddress() string {
	if m != nil {
		return m.SignerAddress
	}
	return ""
}

func (m *SignedTransaction) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *SignedTransaction) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *SignedTransaction) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *SignedTransaction) GetDomain() *ExchangeDomain {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *SignedTransaction) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type ExchangeDomain struct {
	// Address of the Injective Coordinator Contract.
	VerifyingContract string `protobuf:"bytes,1,opt,name=verifying_contract,json=verifyingContract,proto3" json:"verifying_contract,omitempty"`
	// Ethereum Chain ID of the transaction
	ChainId string `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *ExchangeDomain) Reset()         { *m = ExchangeDomain{} }
func (m *ExchangeDomain) String() string { return proto.CompactTextString(m) }
func (*ExchangeDomain) ProtoMessage()    {}
func (*ExchangeDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{6}
}
func (m *ExchangeDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDomain.Merge(m, src)
}
func (m *ExchangeDomain) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDomain.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDomain proto.InternalMessageInfo

func (m *ExchangeDomain) GetVerifyingContract() string {
	if m != nil {
		return m.VerifyingContract
	}
	return ""
}

func (m *ExchangeDomain) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type FillSignatures struct {
	// EIP712 hash of order (see LibOrder.getTypedDataHash)
	OrderHash string `protobuf:"bytes,1,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// Array of signatures that correspond to the required signatures to execute
	// each order in the transaction
	ApprovalSignatures []string `protobuf:"bytes,2,rep,name=approval_signatures,json=approvalSignatures,proto3" json:"approval_signatures,omitempty"`
	// Timestamp in seconds at which approval expires
	ExpirationTimeSeconds string `protobuf:"bytes,3,opt,name=expiration_time_seconds,json=expirationTimeSeconds,proto3" json:"expiration_time_seconds,omitempty"`
	// Desired amount of takerAsset to sell
	TakerAssetFillAmount string `protobuf:"bytes,4,opt,name=taker_asset_fill_amount,json=takerAssetFillAmount,proto3" json:"taker_asset_fill_amount,omitempty"`
}

func (m *FillSignatures) Reset()         { *m = FillSignatures{} }
func (m *FillSignatures) String() string { return proto.CompactTextString(m) }
func (*FillSignatures) ProtoMessage()    {}
func (*FillSignatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{7}
}
func (m *FillSignatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FillSignatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FillSignatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FillSignatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FillSignatures.Merge(m, src)
}
func (m *FillSignatures) XXX_Size() int {
	return m.Size()
}
func (m *FillSignatures) XXX_DiscardUnknown() {
	xxx_messageInfo_FillSignatures.DiscardUnknown(m)
}

var xxx_messageInfo_FillSignatures proto.InternalMessageInfo

func (m *FillSignatures) GetOrderHash() string {
	if m != nil {
		return m.OrderHash
	}
	return ""
}

func (m *FillSignatures) GetApprovalSignatures() []string {
	if m != nil {
		return m.ApprovalSignatures
	}
	return nil
}

func (m *FillSignatures) GetExpirationTimeSeconds() string {
	if m != nil {
		return m.ExpirationTimeSeconds
	}
	return ""
}

func (m *FillSignatures) GetTakerAssetFillAmount() string {
	if m != nil {
		return m.TakerAssetFillAmount
	}
	return ""
}

type EvmSyncStatus struct {
	LatestBlockSynced int64 `protobuf:"zigzag64,1,opt,name=latest_block_synced,json=latestBlockSynced,proto3" json:"latest_block_synced,omitempty"`
}

func (m *EvmSyncStatus) Reset()         { *m = EvmSyncStatus{} }
func (m *EvmSyncStatus) String() string { return proto.CompactTextString(m) }
func (*EvmSyncStatus) ProtoMessage()    {}
func (*EvmSyncStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{8}
}
func (m *EvmSyncStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvmSyncStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvmSyncStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvmSyncStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvmSyncStatus.Merge(m, src)
}
func (m *EvmSyncStatus) XXX_Size() int {
	return m.Size()
}
func (m *EvmSyncStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_EvmSyncStatus.DiscardUnknown(m)
}

var xxx_messageInfo_EvmSyncStatus proto.InternalMessageInfo

func (m *EvmSyncStatus) GetLatestBlockSynced() int64 {
	if m != nil {
		return m.LatestBlockSynced
	}
	return 0
}

type ZeroExTransaction struct {
	ZeroExTransactionType int64    `protobuf:"zigzag64,1,opt,name=zero_ex_transaction_type,json=zeroExTransactionType,proto3" json:"zero_ex_transaction_type,omitempty"`
	Orders                []string `protobuf:"bytes,2,rep,name=orders,proto3" json:"orders,omitempty"`
}

func (m *ZeroExTransaction) Reset()         { *m = ZeroExTransaction{} }
func (m *ZeroExTransaction) String() string { return proto.CompactTextString(m) }
func (*ZeroExTransaction) ProtoMessage()    {}
func (*ZeroExTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{9}
}
func (m *ZeroExTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZeroExTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZeroExTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZeroExTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZeroExTransaction.Merge(m, src)
}
func (m *ZeroExTransaction) XXX_Size() int {
	return m.Size()
}
func (m *ZeroExTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_ZeroExTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_ZeroExTransaction proto.InternalMessageInfo

func (m *ZeroExTransaction) GetZeroExTransactionType() int64 {
	if m != nil {
		return m.ZeroExTransactionType
	}
	return 0
}

func (m *ZeroExTransaction) GetOrders() []string {
	if m != nil {
		return m.Orders
	}
	return nil
}

type MsgCreateSpotOrder struct {
	Sender string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order  *BaseOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *MsgCreateSpotOrder) Reset()         { *m = MsgCreateSpotOrder{} }
func (m *MsgCreateSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateSpotOrder) ProtoMessage()    {}
func (*MsgCreateSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{10}
}
func (m *MsgCreateSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateSpotOrder.Merge(m, src)
}
func (m *MsgCreateSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateSpotOrder proto.InternalMessageInfo

type MsgCreateDerivativeOrder struct {
	Sender                 string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Order                  *BaseOrder `protobuf:"bytes,2,opt,name=order,proto3" json:"order,omitempty"`
	InitialQuantityMatched string     `protobuf:"bytes,3,opt,name=initial_quantity_matched,json=initialQuantityMatched,proto3" json:"initial_quantity_matched,omitempty"`
}

func (m *MsgCreateDerivativeOrder) Reset()         { *m = MsgCreateDerivativeOrder{} }
func (m *MsgCreateDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCreateDerivativeOrder) ProtoMessage()    {}
func (*MsgCreateDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{11}
}
func (m *MsgCreateDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateDerivativeOrder.Merge(m, src)
}
func (m *MsgCreateDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateDerivativeOrder proto.InternalMessageInfo

type MsgRequestFillSpotOrder struct {
	Sender            string             `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SignedTransaction *SignedTransaction `protobuf:"bytes,2,opt,name=signed_transaction,json=signedTransaction,proto3" json:"signed_transaction,omitempty"`
	TxOrigin          string             `protobuf:"bytes,3,opt,name=tx_origin,json=txOrigin,proto3" json:"tx_origin,omitempty"`
	ApprovalSignature string             `protobuf:"bytes,4,opt,name=approval_signature,json=approvalSignature,proto3" json:"approval_signature,omitempty"`
}

func (m *MsgRequestFillSpotOrder) Reset()         { *m = MsgRequestFillSpotOrder{} }
func (m *MsgRequestFillSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgRequestFillSpotOrder) ProtoMessage()    {}
func (*MsgRequestFillSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{12}
}
func (m *MsgRequestFillSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestFillSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestFillSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestFillSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestFillSpotOrder.Merge(m, src)
}
func (m *MsgRequestFillSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestFillSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestFillSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestFillSpotOrder proto.InternalMessageInfo

type MsgRequestSoftCancelSpotOrder struct {
	Sender            string             `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	SignedTransaction *SignedTransaction `protobuf:"bytes,2,opt,name=signed_transaction,json=signedTransaction,proto3" json:"signed_transaction,omitempty"`
	TxOrigin          string             `protobuf:"bytes,3,opt,name=tx_origin,json=txOrigin,proto3" json:"tx_origin,omitempty"`
	ApprovalSignature string             `protobuf:"bytes,4,opt,name=approval_signature,json=approvalSignature,proto3" json:"approval_signature,omitempty"`
}

func (m *MsgRequestSoftCancelSpotOrder) Reset()         { *m = MsgRequestSoftCancelSpotOrder{} }
func (m *MsgRequestSoftCancelSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgRequestSoftCancelSpotOrder) ProtoMessage()    {}
func (*MsgRequestSoftCancelSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{13}
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRequestSoftCancelSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRequestSoftCancelSpotOrder.Merge(m, src)
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgRequestSoftCancelSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRequestSoftCancelSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRequestSoftCancelSpotOrder proto.InternalMessageInfo

type MsgFilledSpotOrder struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	BlockNum     int64  `protobuf:"zigzag64,2,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	TxHash       string `protobuf:"bytes,3,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	OrderHash    string `protobuf:"bytes,4,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	AmountFilled string `protobuf:"bytes,5,opt,name=amount_filled,json=amountFilled,proto3" json:"amount_filled,omitempty"`
}

func (m *MsgFilledSpotOrder) Reset()         { *m = MsgFilledSpotOrder{} }
func (m *MsgFilledSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgFilledSpotOrder) ProtoMessage()    {}
func (*MsgFilledSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{14}
}
func (m *MsgFilledSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFilledSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFilledSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFilledSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFilledSpotOrder.Merge(m, src)
}
func (m *MsgFilledSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgFilledSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFilledSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFilledSpotOrder proto.InternalMessageInfo

type MsgCancelledSpotOrder struct {
	Sender    string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	BlockNum  int64  `protobuf:"zigzag64,2,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	TxHash    string `protobuf:"bytes,3,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	OrderHash string `protobuf:"bytes,4,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
}

func (m *MsgCancelledSpotOrder) Reset()         { *m = MsgCancelledSpotOrder{} }
func (m *MsgCancelledSpotOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelledSpotOrder) ProtoMessage()    {}
func (*MsgCancelledSpotOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{15}
}
func (m *MsgCancelledSpotOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelledSpotOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelledSpotOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelledSpotOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelledSpotOrder.Merge(m, src)
}
func (m *MsgCancelledSpotOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelledSpotOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelledSpotOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelledSpotOrder proto.InternalMessageInfo

type MsgFilledDerivativeOrder struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	BlockNum       int64  `protobuf:"zigzag64,2,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	TxHash         string `protobuf:"bytes,3,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	MakerAddress   string `protobuf:"bytes,4,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	MarketId       string `protobuf:"bytes,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	OrderHash      string `protobuf:"bytes,6,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	PositionId     string `protobuf:"bytes,7,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
	QuantityFilled string `protobuf:"bytes,8,opt,name=quantity_filled,json=quantityFilled,proto3" json:"quantity_filled,omitempty"`
	ContractPrice  string `protobuf:"bytes,9,opt,name=contract_price,json=contractPrice,proto3" json:"contract_price,omitempty"`
	IsLong         bool   `protobuf:"varint,10,opt,name=is_long,json=isLong,proto3" json:"is_long,omitempty"`
}

func (m *MsgFilledDerivativeOrder) Reset()         { *m = MsgFilledDerivativeOrder{} }
func (m *MsgFilledDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*MsgFilledDerivativeOrder) ProtoMessage()    {}
func (*MsgFilledDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{16}
}
func (m *MsgFilledDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFilledDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFilledDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFilledDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFilledDerivativeOrder.Merge(m, src)
}
func (m *MsgFilledDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgFilledDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFilledDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFilledDerivativeOrder proto.InternalMessageInfo

type MsgCancelledDerivativeOrder struct {
	Sender       string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	BlockNum     int64  `protobuf:"zigzag64,2,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	TxHash       string `protobuf:"bytes,3,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	MakerAddress string `protobuf:"bytes,4,opt,name=maker_address,json=makerAddress,proto3" json:"maker_address,omitempty"`
	MarketId     string `protobuf:"bytes,5,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	OrderHash    string `protobuf:"bytes,6,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	PositionId   string `protobuf:"bytes,7,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty"`
}

func (m *MsgCancelledDerivativeOrder) Reset()         { *m = MsgCancelledDerivativeOrder{} }
func (m *MsgCancelledDerivativeOrder) String() string { return proto.CompactTextString(m) }
func (*MsgCancelledDerivativeOrder) ProtoMessage()    {}
func (*MsgCancelledDerivativeOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{17}
}
func (m *MsgCancelledDerivativeOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelledDerivativeOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelledDerivativeOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelledDerivativeOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelledDerivativeOrder.Merge(m, src)
}
func (m *MsgCancelledDerivativeOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelledDerivativeOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelledDerivativeOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelledDerivativeOrder proto.InternalMessageInfo

type MsgRegisterSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
	Enabled        bool   `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *MsgRegisterSpotMarket) Reset()         { *m = MsgRegisterSpotMarket{} }
func (m *MsgRegisterSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterSpotMarket) ProtoMessage()    {}
func (*MsgRegisterSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{18}
}
func (m *MsgRegisterSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterSpotMarket.Merge(m, src)
}
func (m *MsgRegisterSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterSpotMarket proto.InternalMessageInfo

type MsgSuspendSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
}

func (m *MsgSuspendSpotMarket) Reset()         { *m = MsgSuspendSpotMarket{} }
func (m *MsgSuspendSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgSuspendSpotMarket) ProtoMessage()    {}
func (*MsgSuspendSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{19}
}
func (m *MsgSuspendSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSuspendSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSuspendSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSuspendSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSuspendSpotMarket.Merge(m, src)
}
func (m *MsgSuspendSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSuspendSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSuspendSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSuspendSpotMarket proto.InternalMessageInfo

type MsgResumeSpotMarket struct {
	Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MakerAssetData string `protobuf:"bytes,3,opt,name=maker_asset_data,json=makerAssetData,proto3" json:"maker_asset_data,omitempty"`
	TakerAssetData string `protobuf:"bytes,4,opt,name=taker_asset_data,json=takerAssetData,proto3" json:"taker_asset_data,omitempty"`
}

func (m *MsgResumeSpotMarket) Reset()         { *m = MsgResumeSpotMarket{} }
func (m *MsgResumeSpotMarket) String() string { return proto.CompactTextString(m) }
func (*MsgResumeSpotMarket) ProtoMessage()    {}
func (*MsgResumeSpotMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{20}
}
func (m *MsgResumeSpotMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResumeSpotMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResumeSpotMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResumeSpotMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResumeSpotMarket.Merge(m, src)
}
func (m *MsgResumeSpotMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgResumeSpotMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResumeSpotMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResumeSpotMarket proto.InternalMessageInfo

type MsgRegisterDerivativeMarket struct {
	Sender string            `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Market *DerivativeMarket `protobuf:"bytes,2,opt,name=market,proto3" json:"market,omitempty"`
}

func (m *MsgRegisterDerivativeMarket) Reset()         { *m = MsgRegisterDerivativeMarket{} }
func (m *MsgRegisterDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterDerivativeMarket) ProtoMessage()    {}
func (*MsgRegisterDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{21}
}
func (m *MsgRegisterDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterDerivativeMarket.Merge(m, src)
}
func (m *MsgRegisterDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterDerivativeMarket proto.InternalMessageInfo

type MsgSuspendDerivativeMarket struct {
	Sender   string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *MsgSuspendDerivativeMarket) Reset()         { *m = MsgSuspendDerivativeMarket{} }
func (m *MsgSuspendDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgSuspendDerivativeMarket) ProtoMessage()    {}
func (*MsgSuspendDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{22}
}
func (m *MsgSuspendDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSuspendDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSuspendDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSuspendDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSuspendDerivativeMarket.Merge(m, src)
}
func (m *MsgSuspendDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSuspendDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSuspendDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSuspendDerivativeMarket proto.InternalMessageInfo

type MsgResumeDerivativeMarket struct {
	Sender   string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	MarketId string `protobuf:"bytes,2,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
}

func (m *MsgResumeDerivativeMarket) Reset()         { *m = MsgResumeDerivativeMarket{} }
func (m *MsgResumeDerivativeMarket) String() string { return proto.CompactTextString(m) }
func (*MsgResumeDerivativeMarket) ProtoMessage()    {}
func (*MsgResumeDerivativeMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_93e6409a7b611c2d, []int{23}
}
func (m *MsgResumeDerivativeMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResumeDerivativeMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResumeDerivativeMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResumeDerivativeMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResumeDerivativeMarket.Merge(m, src)
}
func (m *MsgResumeDerivativeMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgResumeDerivativeMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResumeDerivativeMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResumeDerivativeMarket proto.InternalMessageInfo

func init() {
	proto.RegisterType((*DerivativeMarket)(nil), "ethermint.orders.v1beta1.DerivativeMarket")
	proto.RegisterType((*TradePair)(nil), "ethermint.orders.v1beta1.TradePair")
	proto.RegisterType((*ContractSet)(nil), "ethermint.orders.v1beta1.ContractSet")
	proto.RegisterType((*BaseOrder)(nil), "ethermint.orders.v1beta1.BaseOrder")
	proto.RegisterType((*Order)(nil), "ethermint.orders.v1beta1.Order")
	proto.RegisterType((*SignedTransaction)(nil), "ethermint.orders.v1beta1.SignedTransaction")
	proto.RegisterType((*ExchangeDomain)(nil), "ethermint.orders.v1beta1.ExchangeDomain")
	proto.RegisterType((*FillSignatures)(nil), "ethermint.orders.v1beta1.FillSignatures")
	proto.RegisterType((*EvmSyncStatus)(nil), "ethermint.orders.v1beta1.EvmSyncStatus")
	proto.RegisterType((*ZeroExTransaction)(nil), "ethermint.orders.v1beta1.ZeroExTransaction")
	proto.RegisterType((*MsgCreateSpotOrder)(nil), "ethermint.orders.v1beta1.MsgCreateSpotOrder")
	proto.RegisterType((*MsgCreateDerivativeOrder)(nil), "ethermint.orders.v1beta1.MsgCreateDerivativeOrder")
	proto.RegisterType((*MsgRequestFillSpotOrder)(nil), "ethermint.orders.v1beta1.MsgRequestFillSpotOrder")
	proto.RegisterType((*MsgRequestSoftCancelSpotOrder)(nil), "ethermint.orders.v1beta1.MsgRequestSoftCancelSpotOrder")
	proto.RegisterType((*MsgFilledSpotOrder)(nil), "ethermint.orders.v1beta1.MsgFilledSpotOrder")
	proto.RegisterType((*MsgCancelledSpotOrder)(nil), "ethermint.orders.v1beta1.MsgCancelledSpotOrder")
	proto.RegisterType((*MsgFilledDerivativeOrder)(nil), "ethermint.orders.v1beta1.MsgFilledDerivativeOrder")
	proto.RegisterType((*MsgCancelledDerivativeOrder)(nil), "ethermint.orders.v1beta1.MsgCancelledDerivativeOrder")
	proto.RegisterType((*MsgRegisterSpotMarket)(nil), "ethermint.orders.v1beta1.MsgRegisterSpotMarket")
	proto.RegisterType((*MsgSuspendSpotMarket)(nil), "ethermint.orders.v1beta1.MsgSuspendSpotMarket")
	proto.RegisterType((*MsgResumeSpotMarket)(nil), "ethermint.orders.v1beta1.MsgResumeSpotMarket")
	proto.RegisterType((*MsgRegisterDerivativeMarket)(nil), "ethermint.orders.v1beta1.MsgRegisterDerivativeMarket")
	proto.RegisterType((*MsgSuspendDerivativeMarket)(nil), "ethermint.orders.v1beta1.MsgSuspendDerivativeMarket")
	proto.RegisterType((*MsgResumeDerivativeMarket)(nil), "ethermint.orders.v1beta1.MsgResumeDerivativeMarket")
}

func init() {
	proto.RegisterFile("ethermint/orders/v1beta1/orders.proto", fileDescriptor_93e6409a7b611c2d)
}

var fileDescriptor_93e6409a7b611c2d = []byte{
	// 1508 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4f, 0x4f, 0x1c, 0x47,
	0x16, 0xa7, 0x61, 0x18, 0x98, 0x07, 0x03, 0x4c, 0x01, 0xa6, 0x6d, 0xd6, 0xd8, 0x1a, 0xe4, 0x5d,
	0xd6, 0xf6, 0x82, 0xec, 0xd5, 0xfe, 0xbd, 0xec, 0x1a, 0xb0, 0x15, 0x4b, 0x21, 0x76, 0x66, 0x48,
	0x22, 0x71, 0x69, 0x15, 0xdd, 0x8f, 0xa6, 0xc4, 0x74, 0xf5, 0xb8, 0xaa, 0x66, 0x34, 0xf8, 0x92,
	0x6b, 0x94, 0x53, 0x6e, 0x39, 0x24, 0x87, 0xe4, 0x94, 0x8b, 0x73, 0x8b, 0x94, 0x6f, 0x10, 0xe5,
	0x16, 0x1f, 0x93, 0x53, 0x22, 0x5b, 0xf9, 0x04, 0xf9, 0x02, 0x51, 0xfd, 0xe9, 0x99, 0x9e, 0x61,
	0xc0, 0x24, 0x4a, 0x14, 0xcb, 0xb7, 0xae, 0xf7, 0x7e, 0x55, 0xfd, 0x7b, 0xf5, 0x7e, 0xef, 0x55,
	0x75, 0xc3, 0x35, 0x54, 0x87, 0x28, 0x12, 0xc6, 0xd5, 0x46, 0x2a, 0x22, 0x14, 0x72, 0xa3, 0x7d,
	0x6b, 0x1f, 0x15, 0xbd, 0xe5, 0x86, 0xeb, 0x4d, 0x91, 0xaa, 0x94, 0xf8, 0x5d, 0xd8, 0xba, 0xb3,
	0x3b, 0xd8, 0xa5, 0x85, 0x38, 0x8d, 0x53, 0x03, 0xda, 0xd0, 0x4f, 0x16, 0x5f, 0xfd, 0xc2, 0x83,
	0xb9, 0x6d, 0x14, 0xac, 0x4d, 0x15, 0x6b, 0xe3, 0x0e, 0x15, 0x47, 0xa8, 0xc8, 0x05, 0x28, 0x2a,
	0x16, 0x1e, 0xa1, 0xf0, 0xbd, 0xab, 0xde, 0x5a, 0xa9, 0xe6, 0x46, 0xda, 0x9e, 0x0a, 0x1a, 0x36,
	0xd0, 0x1f, 0xb5, 0x76, 0x3b, 0x22, 0xab, 0x50, 0xde, 0xa7, 0x12, 0x83, 0xb0, 0x25, 0x04, 0xf2,
	0xf0, 0xd8, 0x1f, 0x33, 0xee, 0x69, 0x6d, 0xdc, 0x72, 0x36, 0xb2, 0x00, 0xe3, 0x3c, 0xe5, 0x21,
	0xfa, 0x05, 0xe3, 0xb4, 0x03, 0xb2, 0x0c, 0xa5, 0xc4, 0xbc, 0x34, 0x60, 0x91, 0x3f, 0x6e, 0x3c,
	0x93, 0xd6, 0x70, 0x3f, 0x22, 0x3e, 0x4c, 0x20, 0xa7, 0xfb, 0x0d, 0x8c, 0xfc, 0xe2, 0x55, 0x6f,
	0x6d, 0xb2, 0x96, 0x0d, 0xab, 0x9f, 0x7a, 0x50, 0xda, 0x15, 0x34, 0xc2, 0x87, 0x94, 0x09, 0x42,
	0xa0, 0xc0, 0x69, 0x82, 0x8e, 0xad, 0x79, 0x26, 0x6b, 0x30, 0x97, 0xd0, 0x23, 0x14, 0x01, 0x95,
	0x12, 0x55, 0x10, 0x51, 0x45, 0x1d, 0xeb, 0x19, 0x63, 0xbf, 0xa3, 0xcd, 0xdb, 0x54, 0x51, 0x8d,
	0x54, 0x83, 0x48, 0x1b, 0xc0, 0x8c, 0xea, 0x47, 0x12, 0x28, 0x1c, 0x52, 0x79, 0xe8, 0x22, 0x30,
	0xcf, 0x79, 0x8e, 0xe3, 0xfd, 0x1c, 0xbf, 0xf2, 0x60, 0x6a, 0x2b, 0xe5, 0x4a, 0xd0, 0x50, 0xd5,
	0x51, 0x91, 0x5b, 0xb0, 0x10, 0xa6, 0xa9, 0x88, 0x18, 0xa7, 0x2a, 0x15, 0x41, 0xe8, 0x5c, 0x8e,
	0xf5, 0x7c, 0xce, 0x97, 0xcd, 0x22, 0x37, 0x81, 0x44, 0xd8, 0x0e, 0x5a, 0x8a, 0x35, 0x64, 0x6f,
	0x82, 0x0d, 0x63, 0x2e, 0xc2, 0xf6, 0x5b, 0xda, 0xd1, 0x45, 0xdf, 0x80, 0x0a, 0x76, 0xc2, 0x43,
	0xca, 0x63, 0xec, 0x81, 0x6d, 0x24, 0x73, 0x99, 0xa3, 0x0b, 0xfe, 0x2b, 0xcc, 0x1d, 0xb4, 0x54,
	0x4b, 0x60, 0x6e, 0x61, 0x1b, 0xd7, 0xac, 0xb3, 0x67, 0xd0, 0xea, 0x93, 0x71, 0x28, 0x6d, 0x52,
	0x89, 0x0f, 0xb4, 0xa0, 0xc8, 0x45, 0x98, 0x0c, 0x0f, 0x29, 0xe3, 0x3a, 0x61, 0x9a, 0x3a, 0xa9,
	0x4d, 0x98, 0xf1, 0xfd, 0x48, 0xaf, 0xd9, 0x25, 0x40, 0xa3, 0x48, 0xa0, 0x94, 0x8e, 0xec, 0x6c,
	0x66, 0xbf, 0x63, 0xcd, 0x5a, 0x32, 0x2e, 0x3d, 0x0e, 0xe7, 0x24, 0x63, 0x73, 0xd3, 0x03, 0xa9,
	0x3e, 0x90, 0x25, 0x38, 0xad, 0xf2, 0xa0, 0xdb, 0xb0, 0x78, 0x80, 0x18, 0x08, 0x0c, 0x59, 0x93,
	0x21, 0x57, 0x5d, 0xb0, 0x55, 0xd3, 0xfc, 0x01, 0x62, 0x2d, 0xf3, 0x65, 0x73, 0xae, 0xc1, 0x8c,
	0x44, 0x1e, 0xe5, 0x56, 0x2e, 0x1a, 0x70, 0xd9, 0x5a, 0x33, 0xd8, 0x4d, 0x20, 0x79, 0x0d, 0xd1,
	0x24, 0x6d, 0x71, 0xe5, 0x4f, 0xd8, 0x1d, 0xed, 0xa9, 0xe8, 0x8e, 0xb1, 0x6b, 0xb4, 0x3a, 0x89,
	0x9e, 0xb4, 0x68, 0x35, 0x88, 0x36, 0xc2, 0xd7, 0xe8, 0x03, 0x44, 0xbf, 0x94, 0x09, 0xff, 0x08,
	0xc5, 0x3d, 0x34, 0x55, 0xa1, 0xba, 0x4e, 0xb0, 0x4e, 0x95, 0x39, 0xff, 0x09, 0x4b, 0xd8, 0x69,
	0x32, 0x41, 0x15, 0x4b, 0x79, 0xa0, 0x58, 0x82, 0x81, 0xc4, 0x30, 0xe5, 0x91, 0xf4, 0xa7, 0x0c,
	0x74, 0xb1, 0xe7, 0xde, 0x65, 0x09, 0xd6, 0xad, 0x53, 0xab, 0x57, 0xd2, 0x86, 0xf2, 0xa7, 0xad,
	0x7a, 0xf5, 0xf3, 0xd0, 0x2a, 0x29, 0x9f, 0xbb, 0x4a, 0x66, 0x86, 0x56, 0xc9, 0x06, 0x2c, 0x74,
	0x23, 0xcb, 0xa3, 0x67, 0x0d, 0xba, 0x92, 0x05, 0xd9, 0x37, 0x41, 0x0d, 0x9b, 0x30, 0x67, 0x27,
	0xa8, 0x13, 0x13, 0xfe, 0x04, 0x25, 0xc9, 0x62, 0x4e, 0xb5, 0x4c, 0xfd, 0x8a, 0x41, 0xf5, 0x0c,
	0xd5, 0xcf, 0x3c, 0x18, 0xb7, 0x52, 0xfd, 0x0f, 0x8c, 0x9b, 0x26, 0x68, 0x74, 0x3a, 0x75, 0x7b,
	0x75, 0xfd, 0xb4, 0xe6, 0xb8, 0xde, 0x95, 0x77, 0xcd, 0xce, 0x20, 0x7f, 0x86, 0x59, 0xa5, 0xfb,
	0x4b, 0xd0, 0xa4, 0x4c, 0x04, 0xa6, 0xea, 0xad, 0x92, 0xcb, 0x2a, 0x6b, 0x3b, 0xaf, 0xe9, 0xf2,
	0x5f, 0x85, 0xf2, 0x01, 0x6b, 0x34, 0x30, 0xca, 0xf2, 0xed, 0x74, 0x6c, 0x8d, 0x2e, 0xd7, 0x17,
	0xa0, 0x28, 0x15, 0x55, 0x2d, 0x2b, 0x60, 0x52, 0x73, 0xa3, 0xea, 0x87, 0xa3, 0x50, 0xa9, 0xb3,
	0x98, 0x63, 0xb4, 0x2b, 0x28, 0x97, 0x34, 0xd4, 0x29, 0xeb, 0xe6, 0xc9, 0xcb, 0xe5, 0x49, 0x0b,
	0x56, 0x03, 0xc5, 0x40, 0x5d, 0x95, 0xad, 0x35, 0x13, 0x2c, 0x81, 0x42, 0xae, 0x7d, 0x99, 0xe7,
	0xb3, 0xe4, 0x52, 0x38, 0x4b, 0x2e, 0xcb, 0x50, 0x8a, 0xa9, 0x0c, 0x9a, 0x82, 0x85, 0x98, 0x75,
	0xe6, 0x98, 0xca, 0x87, 0x7a, 0x4c, 0xfe, 0x0f, 0xc5, 0x28, 0x4d, 0x28, 0xe3, 0xa6, 0x70, 0xa6,
	0x6e, 0xaf, 0x9d, 0xbe, 0xb5, 0x77, 0x5d, 0xe5, 0x6f, 0x1b, 0x7c, 0xcd, 0xcd, 0xeb, 0xcf, 0xe1,
	0xc4, 0x60, 0x0e, 0xf7, 0x60, 0xa6, 0x7f, 0x1e, 0xf9, 0x1b, 0x90, 0x36, 0x0a, 0x76, 0x70, 0xcc,
	0x78, 0x3c, 0xd8, 0x3b, 0x2b, 0x5d, 0x4f, 0xb7, 0xbd, 0xe5, 0xbb, 0x94, 0xdd, 0xaa, 0xac, 0x4b,
	0x55, 0xbf, 0xf1, 0x60, 0xe6, 0x1e, 0x6b, 0x34, 0xea, 0xd9, 0xdb, 0x24, 0xb9, 0x0c, 0x60, 0x58,
	0xdb, 0x44, 0xdb, 0x45, 0x4b, 0xc6, 0x62, 0x92, 0xbc, 0x01, 0xf3, 0xb4, 0xd9, 0x14, 0x69, 0x9b,
	0x36, 0x82, 0x2e, 0x47, 0x9d, 0x82, 0xb1, 0xb5, 0x52, 0x8d, 0x64, 0xae, 0xdc, 0x7a, 0x67, 0xec,
	0xf9, 0xd8, 0x59, 0x7b, 0xfe, 0x0f, 0x58, 0xca, 0x17, 0x99, 0x16, 0x51, 0xa6, 0x2b, 0x9b, 0xab,
	0x85, 0x5e, 0xad, 0xe9, 0x10, 0xac, 0xbe, 0xaa, 0xff, 0x83, 0xf2, 0xdd, 0x76, 0x52, 0x3f, 0xe6,
	0x61, 0xdd, 0x08, 0x8b, 0xac, 0xc3, 0x7c, 0x83, 0x2a, 0x94, 0x2a, 0xd8, 0x6f, 0xa4, 0xe1, 0x51,
	0x20, 0x8f, 0x79, 0x88, 0x59, 0xbb, 0xae, 0x58, 0xd7, 0xa6, 0xf6, 0xd4, 0x8d, 0xa3, 0x1a, 0x41,
	0x65, 0x0f, 0x45, 0x7a, 0xb7, 0x93, 0xd7, 0xe1, 0xbf, 0xc0, 0x7f, 0x8c, 0x22, 0x0d, 0xb0, 0x13,
	0xa8, 0x9e, 0x39, 0x50, 0xc7, 0x4d, 0x74, 0x2b, 0x2d, 0x3e, 0x1e, 0x9c, 0xb4, 0x7b, 0xdc, 0x44,
	0x7b, 0x4d, 0xd0, 0x1a, 0x70, 0x3b, 0xe4, 0x46, 0xd5, 0x04, 0xc8, 0x8e, 0x8c, 0xb7, 0x04, 0x52,
	0x85, 0xf5, 0x66, 0xaa, 0x6c, 0x91, 0xea, 0xe2, 0x30, 0x5d, 0x37, 0xbb, 0x6c, 0xd8, 0x51, 0xaf,
	0x78, 0x47, 0x7f, 0x69, 0xf1, 0xfe, 0xb7, 0xf0, 0xde, 0x27, 0x57, 0x46, 0xaa, 0x9f, 0x7b, 0xe0,
	0x77, 0xdf, 0xd7, 0xbb, 0xe3, 0xfc, 0x5e, 0x6f, 0x25, 0xff, 0x06, 0x9f, 0x71, 0xa6, 0x18, 0x6d,
	0x04, 0x8f, 0x5a, 0x94, 0x2b, 0xa6, 0x8e, 0x83, 0x84, 0xaa, 0xf0, 0x10, 0x23, 0x97, 0xf5, 0x0b,
	0xce, 0xff, 0xa6, 0x73, 0xef, 0x58, 0xaf, 0xe3, 0xfb, 0xbd, 0x07, 0x4b, 0x3b, 0x32, 0xae, 0xe1,
	0xa3, 0x16, 0x4a, 0x93, 0xde, 0x17, 0x6f, 0xd2, 0x1e, 0x10, 0xd3, 0x01, 0xa2, 0x7c, 0x8a, 0x1c,
	0xf7, 0x1b, 0xa7, 0x73, 0x3f, 0xd1, 0x74, 0x6a, 0x15, 0x79, 0xa2, 0x0f, 0xe9, 0x43, 0xa8, 0x13,
	0xa4, 0x82, 0xc5, 0x8c, 0xbb, 0x00, 0x26, 0x55, 0xe7, 0x81, 0x19, 0xeb, 0x72, 0x3c, 0x59, 0x12,
	0x4e, 0xa4, 0x95, 0x13, 0x15, 0xe1, 0x22, 0xfc, 0xd1, 0x83, 0xcb, 0xbd, 0x08, 0xeb, 0xe9, 0x81,
	0xda, 0xa2, 0x3c, 0xc4, 0x57, 0x2e, 0xce, 0x27, 0x9e, 0x51, 0xfa, 0x3d, 0x73, 0x06, 0xbc, 0x38,
	0xb8, 0x65, 0x28, 0xd9, 0x32, 0xe5, 0xad, 0xc4, 0xc4, 0x44, 0x6a, 0x93, 0xc6, 0xf0, 0x46, 0x2b,
	0x21, 0x4b, 0x30, 0xa1, 0x3a, 0xb6, 0x2f, 0x8d, 0xb9, 0xcb, 0x78, 0xc7, 0x34, 0xa5, 0xfe, 0x9e,
	0x55, 0x18, 0xec, 0x59, 0xab, 0x50, 0xb6, 0x9d, 0x23, 0xb0, 0x47, 0x91, 0x6b, 0xe1, 0xd3, 0xd6,
	0x68, 0xa9, 0x39, 0xba, 0xef, 0x7b, 0xb0, 0xa8, 0x0b, 0xc5, 0xe4, 0xe2, 0x0f, 0x63, 0xec, 0xc8,
	0x7c, 0x37, 0x6a, 0xaa, 0xd6, 0x12, 0x3c, 0x6f, 0xd5, 0xfe, 0x3a, 0x3e, 0x27, 0xee, 0xa0, 0x85,
	0x21, 0x77, 0xd0, 0x33, 0x3f, 0x50, 0xfa, 0x23, 0x2a, 0x0e, 0xe6, 0xe0, 0x0a, 0x4c, 0x35, 0x53,
	0xc9, 0x4c, 0xdb, 0x64, 0x91, 0x3b, 0xe5, 0x20, 0x33, 0xdd, 0x8f, 0xc8, 0x5f, 0x60, 0xb6, 0xdb,
	0x2a, 0x5c, 0x9a, 0xec, 0x7d, 0x71, 0x26, 0x33, 0xdb, 0x7d, 0xd0, 0xe7, 0x7f, 0x76, 0xe6, 0xb9,
	0x13, 0xd9, 0x5e, 0x19, 0xcb, 0x99, 0xd5, 0x1e, 0xcb, 0x4b, 0x30, 0xc1, 0x64, 0xd0, 0x48, 0x79,
	0x6c, 0x6e, 0x8d, 0x93, 0xb5, 0x22, 0x93, 0xaf, 0xa7, 0x3c, 0x76, 0x7b, 0xfb, 0x93, 0x07, 0xcb,
	0xf9, 0x44, 0xbf, 0xe2, 0xdb, 0xeb, 0xa2, 0xfe, 0xd2, 0xca, 0xbb, 0x86, 0x31, 0x93, 0x0a, 0x85,
	0x56, 0x77, 0xef, 0x3b, 0x77, 0x68, 0xbc, 0xd9, 0xf7, 0xe4, 0xe8, 0x0b, 0xbe, 0x27, 0xc7, 0xce,
	0x7d, 0x53, 0x2e, 0x0c, 0xbd, 0x29, 0x9f, 0xfa, 0xed, 0xe8, 0x98, 0x7f, 0xec, 0xc1, 0xc2, 0x8e,
	0x8c, 0xeb, 0x2d, 0xd9, 0x44, 0x1e, 0xbd, 0x3c, 0xc4, 0x1d, 0xbd, 0x8f, 0x3c, 0x98, 0x37, 0x1b,
	0x2b, 0x5b, 0x09, 0xbe, 0x74, 0xec, 0xde, 0x35, 0x5a, 0xcf, 0xb2, 0x3e, 0xec, 0x1f, 0xc7, 0x50,
	0x92, 0x9b, 0x50, 0xb4, 0xfa, 0x73, 0xa7, 0xcb, 0xf5, 0xd3, 0x4f, 0x97, 0xc1, 0x35, 0x6b, 0x6e,
	0xa6, 0x23, 0xf0, 0x0e, 0x5c, 0xea, 0x25, 0xef, 0xdc, 0xef, 0xef, 0x2b, 0x88, 0xd1, 0xfe, 0x82,
	0x70, 0x0b, 0xbf, 0x0d, 0x17, 0xbb, 0xdb, 0xfe, 0x1b, 0xae, 0xbb, 0xb9, 0xfd, 0xf5, 0xb3, 0x15,
	0xef, 0xe9, 0xb3, 0x15, 0xef, 0x87, 0x67, 0x2b, 0xde, 0x07, 0xcf, 0x57, 0x46, 0x9e, 0x3e, 0x5f,
	0x19, 0xf9, 0xf6, 0xf9, 0xca, 0xc8, 0xde, 0xf5, 0x98, 0xa9, 0xc3, 0xd6, 0xfe, 0x7a, 0x98, 0x26,
	0x1b, 0x61, 0x2a, 0x93, 0x54, 0x6e, 0xf4, 0x7e, 0x47, 0x75, 0xb2, 0x1f, 0x52, 0xfa, 0x66, 0x28,
	0xf7, 0x8b, 0xe6, 0xc7, 0xd2, 0xdf, 0x7f, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xb4, 0x90, 0x42, 0x01,
	0xb1, 0x12, 0x00, 0x00,
}

func (m *DerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseCurrency) > 0 {
		i -= len(m.BaseCurrency)
		copy(dAtA[i:], m.BaseCurrency)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.BaseCurrency)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Oracle) > 0 {
		i -= len(m.Oracle)
		copy(dAtA[i:], m.Oracle)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Oracle)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TradePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradePair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradePair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FuturesContract) > 0 {
		i -= len(m.FuturesContract)
		copy(dAtA[i:], m.FuturesContract)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FuturesContract)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExchangeContract) > 0 {
		i -= len(m.ExchangeContract)
		copy(dAtA[i:], m.ExchangeContract)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeContract)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DevUtilsContract) > 0 {
		i -= len(m.DevUtilsContract)
		copy(dAtA[i:], m.DevUtilsContract)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.DevUtilsContract)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CoordinatorContract) > 0 {
		i -= len(m.CoordinatorContract)
		copy(dAtA[i:], m.CoordinatorContract)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.CoordinatorContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TakerFeeAssetData) > 0 {
		i -= len(m.TakerFeeAssetData)
		copy(dAtA[i:], m.TakerFeeAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerFeeAssetData)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.MakerFeeAssetData) > 0 {
		i -= len(m.MakerFeeAssetData)
		copy(dAtA[i:], m.MakerFeeAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerFeeAssetData)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.TakerFee) > 0 {
		i -= len(m.TakerFee)
		copy(dAtA[i:], m.TakerFee)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerFee)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MakerFee) > 0 {
		i -= len(m.MakerFee)
		copy(dAtA[i:], m.MakerFee)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerFee)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.TakerAssetAmount) > 0 {
		i -= len(m.TakerAssetAmount)
		copy(dAtA[i:], m.TakerAssetAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetAmount)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MakerAssetAmount) > 0 {
		i -= len(m.MakerAssetAmount)
		copy(dAtA[i:], m.MakerAssetAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetAmount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SenderAddress) > 0 {
		i -= len(m.SenderAddress)
		copy(dAtA[i:], m.SenderAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.SenderAddress)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FeeRecipientAddress) > 0 {
		i -= len(m.FeeRecipientAddress)
		copy(dAtA[i:], m.FeeRecipientAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FeeRecipientAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TakerAddress) > 0 {
		i -= len(m.TakerAddress)
		copy(dAtA[i:], m.TakerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExchangeAddress) > 0 {
		i -= len(m.ExchangeAddress)
		copy(dAtA[i:], m.ExchangeAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExchangeAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.ChainId)<<1)^uint64((m.ChainId>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.Status)<<1)^uint64((m.Status>>63))))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FilledAmount) > 0 {
		i -= len(m.FilledAmount)
		copy(dAtA[i:], m.FilledAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.FilledAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TradePairHash) > 0 {
		i -= len(m.TradePairHash)
		copy(dAtA[i:], m.TradePairHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TradePairHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.GasPrice) > 0 {
		i -= len(m.GasPrice)
		copy(dAtA[i:], m.GasPrice)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.GasPrice)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SignerAddress) > 0 {
		i -= len(m.SignerAddress)
		copy(dAtA[i:], m.SignerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.SignerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerifyingContract) > 0 {
		i -= len(m.VerifyingContract)
		copy(dAtA[i:], m.VerifyingContract)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.VerifyingContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FillSignatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FillSignatures) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FillSignatures) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetFillAmount) > 0 {
		i -= len(m.TakerAssetFillAmount)
		copy(dAtA[i:], m.TakerAssetFillAmount)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetFillAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExpirationTimeSeconds) > 0 {
		i -= len(m.ExpirationTimeSeconds)
		copy(dAtA[i:], m.ExpirationTimeSeconds)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ExpirationTimeSeconds)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApprovalSignatures) > 0 {
		for iNdEx := len(m.ApprovalSignatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ApprovalSignatures[iNdEx])
			copy(dAtA[i:], m.ApprovalSignatures[iNdEx])
			i = encodeVarintOrders(dAtA, i, uint64(len(m.ApprovalSignatures[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvmSyncStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvmSyncStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvmSyncStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatestBlockSynced != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.LatestBlockSynced)<<1)^uint64((m.LatestBlockSynced>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ZeroExTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroExTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZeroExTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Orders) > 0 {
		for iNdEx := len(m.Orders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Orders[iNdEx])
			copy(dAtA[i:], m.Orders[iNdEx])
			i = encodeVarintOrders(dAtA, i, uint64(len(m.Orders[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ZeroExTransactionType != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.ZeroExTransactionType)<<1)^uint64((m.ZeroExTransactionType>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InitialQuantityMatched) > 0 {
		i -= len(m.InitialQuantityMatched)
		copy(dAtA[i:], m.InitialQuantityMatched)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.InitialQuantityMatched)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestFillSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestFillSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestFillSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalSignature) > 0 {
		i -= len(m.ApprovalSignature)
		copy(dAtA[i:], m.ApprovalSignature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ApprovalSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxOrigin) > 0 {
		i -= len(m.TxOrigin)
		copy(dAtA[i:], m.TxOrigin)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TxOrigin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SignedTransaction != nil {
		{
			size, err := m.SignedTransaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRequestSoftCancelSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRequestSoftCancelSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRequestSoftCancelSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ApprovalSignature) > 0 {
		i -= len(m.ApprovalSignature)
		copy(dAtA[i:], m.ApprovalSignature)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ApprovalSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxOrigin) > 0 {
		i -= len(m.TxOrigin)
		copy(dAtA[i:], m.TxOrigin)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TxOrigin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SignedTransaction != nil {
		{
			size, err := m.SignedTransaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFilledSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFilledSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFilledSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmountFilled) > 0 {
		i -= len(m.AmountFilled)
		copy(dAtA[i:], m.AmountFilled)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.AmountFilled)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockNum != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.BlockNum)<<1)^uint64((m.BlockNum>>63))))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelledSpotOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelledSpotOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelledSpotOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockNum != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.BlockNum)<<1)^uint64((m.BlockNum>>63))))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFilledDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFilledDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFilledDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsLong {
		i--
		if m.IsLong {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.ContractPrice) > 0 {
		i -= len(m.ContractPrice)
		copy(dAtA[i:], m.ContractPrice)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.ContractPrice)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.QuantityFilled) > 0 {
		i -= len(m.QuantityFilled)
		copy(dAtA[i:], m.QuantityFilled)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.QuantityFilled)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PositionId) > 0 {
		i -= len(m.PositionId)
		copy(dAtA[i:], m.PositionId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.PositionId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockNum != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.BlockNum)<<1)^uint64((m.BlockNum>>63))))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelledDerivativeOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelledDerivativeOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelledDerivativeOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PositionId) > 0 {
		i -= len(m.PositionId)
		copy(dAtA[i:], m.PositionId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.PositionId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OrderHash) > 0 {
		i -= len(m.OrderHash)
		copy(dAtA[i:], m.OrderHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.OrderHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MakerAddress) > 0 {
		i -= len(m.MakerAddress)
		copy(dAtA[i:], m.MakerAddress)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockNum != 0 {
		i = encodeVarintOrders(dAtA, i, uint64((uint64(m.BlockNum)<<1)^uint64((m.BlockNum>>63))))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSuspendSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSuspendSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSuspendSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResumeSpotMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResumeSpotMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResumeSpotMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TakerAssetData) > 0 {
		i -= len(m.TakerAssetData)
		copy(dAtA[i:], m.TakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.TakerAssetData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MakerAssetData) > 0 {
		i -= len(m.MakerAssetData)
		copy(dAtA[i:], m.MakerAssetData)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MakerAssetData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Market != nil {
		{
			size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrders(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSuspendDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSuspendDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSuspendDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResumeDerivativeMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResumeDerivativeMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResumeDerivativeMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintOrders(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOrders(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrders(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Oracle)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.BaseCurrency)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *TradePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *ContractSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CoordinatorContract)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.DevUtilsContract)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExchangeContract)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FuturesContract)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *BaseOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sozOrders(uint64(m.ChainId))
	}
	l = len(m.ExchangeAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FeeRecipientAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.SenderAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerFee)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerFee)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerFeeAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerFeeAssetData)
	if l > 0 {
		n += 2 + l + sovOrders(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 2 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TradePairHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.FilledAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sozOrders(uint64(m.Status))
	}
	return n
}

func (m *SignedTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.SignerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *ExchangeDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VerifyingContract)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *FillSignatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if len(m.ApprovalSignatures) > 0 {
		for _, s := range m.ApprovalSignatures {
			l = len(s)
			n += 1 + l + sovOrders(uint64(l))
		}
	}
	l = len(m.ExpirationTimeSeconds)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetFillAmount)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *EvmSyncStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LatestBlockSynced != 0 {
		n += 1 + sozOrders(uint64(m.LatestBlockSynced))
	}
	return n
}

func (m *ZeroExTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ZeroExTransactionType != 0 {
		n += 1 + sozOrders(uint64(m.ZeroExTransactionType))
	}
	if len(m.Orders) > 0 {
		for _, s := range m.Orders {
			l = len(s)
			n += 1 + l + sovOrders(uint64(l))
		}
	}
	return n
}

func (m *MsgCreateSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgCreateDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.InitialQuantityMatched)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRequestFillSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.SignedTransaction != nil {
		l = m.SignedTransaction.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TxOrigin)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ApprovalSignature)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRequestSoftCancelSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.SignedTransaction != nil {
		l = m.SignedTransaction.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TxOrigin)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ApprovalSignature)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgFilledSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sozOrders(uint64(m.BlockNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.AmountFilled)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgCancelledSpotOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sozOrders(uint64(m.BlockNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgFilledDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sozOrders(uint64(m.BlockNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.PositionId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.QuantityFilled)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.ContractPrice)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.IsLong {
		n += 2
	}
	return n
}

func (m *MsgCancelledDerivativeOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sozOrders(uint64(m.BlockNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAddress)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.OrderHash)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.PositionId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRegisterSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *MsgSuspendSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgResumeSpotMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.TakerAssetData)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgRegisterDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	if m.Market != nil {
		l = m.Market.Size()
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgSuspendDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func (m *MsgResumeDerivativeMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovOrders(uint64(l))
	}
	return n
}

func sovOrders(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrders(x uint64) (n int) {
	return sovOrders(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oracle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoordinatorContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevUtilsContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevUtilsContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuturesContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuturesContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ChainId = int64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeRecipientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeRecipientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeeAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFeeAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradePairHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradePairHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilledAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Status = int64(v)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &ExchangeDomain{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyingContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyingContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FillSignatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FillSignatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FillSignatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalSignatures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalSignatures = append(m.ApprovalSignatures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimeSeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpirationTimeSeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetFillAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetFillAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvmSyncStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvmSyncStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvmSyncStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlockSynced", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.LatestBlockSynced = int64(v)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroExTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroExTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroExTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroExTransactionType", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ZeroExTransactionType = int64(v)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orders = append(m.Orders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &BaseOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialQuantityMatched", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialQuantityMatched = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestFillSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestFillSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestFillSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedTransaction == nil {
				m.SignedTransaction = &SignedTransaction{}
			}
			if err := m.SignedTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxOrigin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRequestSoftCancelSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRequestSoftCancelSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRequestSoftCancelSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedTransaction == nil {
				m.SignedTransaction = &SignedTransaction{}
			}
			if err := m.SignedTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxOrigin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFilledSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFilledSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFilledSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.BlockNum = int64(v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountFilled", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountFilled = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelledSpotOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelledSpotOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelledSpotOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.BlockNum = int64(v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFilledDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFilledDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFilledDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.BlockNum = int64(v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantityFilled", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuantityFilled = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLong", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLong = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelledDerivativeOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelledDerivativeOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelledDerivativeOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.BlockNum = int64(v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSuspendSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSuspendSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSuspendSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResumeSpotMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResumeSpotMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResumeSpotMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerAssetData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerAssetData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Market == nil {
				m.Market = &DerivativeMarket{}
			}
			if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSuspendDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSuspendDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSuspendDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResumeDerivativeMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResumeDerivativeMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResumeDerivativeMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrders
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrders
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrders(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOrders
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrders(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrders
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrders
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrders
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrders
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrders
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrders        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrders          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrders = fmt.Errorf("proto: unexpected end of group")
)
